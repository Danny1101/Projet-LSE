#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>

#include <unistd.h>
#include <time.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>

#include <linux/unistd.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/wait.h>

#include "log/log.h"
#include "syscalls/syscalls.h"
#define US_TO_NS(X) ((X)*1000)
//=======================================================
const char* usage = "Usage: mtask_launch [args] [executable] [options executable]\n" \
"Lance une tache supervisee.\n" \
"\n" \
"Les arguments obligatoires sont :\n" \
"  -p, --period           Période en microsecondes\n" \
"  -d, --deadline         Echéance en microsecondes\n" \
"  -n, --normal_wcet      Pire temps d'exécution normal en microsecondes\n" \
"  -a, --abnormal_wcet    Pire temps d'exécution anormal en microsecondes\n";
//=======================================================
//=======================================================
void* __monitoring_thread_routine(void*);
static void __error_handle(int cond, const char* str);
static int __parse_attr(int argc, char** argv, struct sched_deadline_params_t*);
static char** __create_argv_array(int argc, char** argv);
static void __clear_argv_array(int argc, char** argv);
//=======================================================
int main(int argc, char** argv){
  pthread_t mthread;
  volatile pid_t cpid = 0;
  int exec_index;
  struct sched_attr task_attr;
  struct rusage usage;
  char** child_argv = NULL;
  int child_argc;
  struct sched_deadline_params_t sched_deadline_params;
  struct raw_log_t raw_log;
  //pthread_create(&thread, NULL, __monitoring_thread_routine, (void*)&pid);

  //================== Set task attr ==================
  task_attr.size = sizeof(struct sched_attr);
  task_attr.sched_flags = 0;
  task_attr.sched_nice = 0;
  task_attr.sched_priority = 0;

  exec_index = __parse_attr(argc, argv, &sched_deadline_params);

  task_attr.sched_policy = SCHED_DEADLINE;
  task_attr.sched_runtime = US_TO_NS((sched_deadline_params.period_us>2000)? 2000 : sched_deadline_params.period_us);
  task_attr.sched_deadline = US_TO_NS((sched_deadline_params.period_us>2000)? 2000 : sched_deadline_params.period_us);
  task_attr.sched_period = US_TO_NS(sched_deadline_params.period_us);
  //=====================================================
  child_argv = __create_argv_array(child_argc=(argc - exec_index), argv + exec_index);
  log_init(&raw_log);
  //======================== FORK =======================
  cpid = fork();
  if(cpid > 0){
    // Parent code
    printf("Parent PID [%d] created child pid [%d]\n", getpid(), cpid);
    if(sched_setattr(0, &task_attr, 0)){
      perror("sched_setattr() ");
      kill(cpid, SIGKILL);
      goto main_dies;
    }
    printf("Parent PID [%d] set period to %d us\n", getpid(), sched_deadline_params.period_us);
    log_offset_mark(&raw_log);
parent_process_loop:
    // preloop processing
    log_preloop_mark(&raw_log);
    // inner loop processing
    if(getrusage(RUSAGE_CHILDREN, &usage)){
      perror("getrusage()");
      kill(cpid, SIGKILL);
      goto main_dies;
    }
    raw_log.utime = usage.ru_utime;
    raw_log.stime = usage.ru_stime;
    raw_log.vcsw = usage.ru_nvcsw;
    raw_log.ivcsw = usage.ru_nivcsw;

    printf("===========================\n");
    printf("raw_log.pid = %d\n",raw_log.pid);
    printf("raw_log.utime = %d %d\n",raw_log.utime.tv_sec,raw_log.utime.tv_usec);
    printf("raw_log.stime = %d %d\n",raw_log.stime.tv_sec,raw_log.stime.tv_usec);
    printf("raw_log.vcsw = %d\n",raw_log.vcsw);
    printf("raw_log.ivcsw = %d\n",raw_log.ivcsw);

    // postloop processing
    log_postloop_mark(&raw_log);
    sched_yield();
    goto parent_process_loop;
    //wait(NULL);
  }else if(!cpid){
    execv(child_argv[0], child_argv);
    printf("Child PID [%d] FAILED \n", getpid());
    exit(EXIT_FAILURE);
  }


  //=====================================================
main_dies:
  __clear_argv_array(child_argc, child_argv);
  log_free(&raw_log);
  return EXIT_SUCCESS;
}
//=======================================================
//=======================================================
//=======================================================
//=======================================================
void* __monitoring_thread_routine(void* _pid){
  struct raw_log_t raw_log;
  struct sched_attr task_attr, monitor_attr;
  pid_t task_id = *((pid_t*)_pid);
  log_init(&raw_log);
  // Assign DEADLINE parameters to sched_attr ....
  monitor_attr.size = sizeof(struct sched_attr);
  monitor_attr.sched_flags = 0;
  monitor_attr.sched_nice = 0;
  monitor_attr.sched_priority = 0;

  // Initializing code ....
  monitor_attr.sched_policy = SCHED_DEADLINE;

  if (sched_getattr(task_id, &task_attr, sizeof(struct sched_attr), 0)) {
        fprintf(stderr, "sched_getattr() : failed, no monitoring will be available for task [%d] ...\n", task_id);
        goto __monitoring_thread_free_resources;
  }
/*
  if (sched_setattr(0, &monitor_attr, 0)) {
        fprintf(stderr, "sched_setattr() : failed, no monitoring will be available for the monitoring thread ...\n");
        goto __monitoring_thread_free_resources;
  }
  */

  switch(task_attr.sched_policy){
    case SCHED_DEADLINE:
      printf("Le processus [%d] utilise la politique d'ordonnancement SCHED_DEADLINE\n", task_id);
      break;
    default:
      fprintf(stderr,"Le processus [%d] n'utilise pas la politique d'ordonnancement SCHED_DEADLINE {%d}, le thread de monitoring va quitter\n", task_id, task_attr.sched_policy);
      break;
  }

  printf("task deadline = %lld\n", task_attr.sched_period);
  printf("task sched_deadline = %lld\n", task_attr.sched_deadline);
  printf("task sched_runtime = %lld\n", task_attr.sched_runtime);

  goto __monitoring_thread_free_resources;

  // Infinite loop and everything else
  raw_log.pid = task_id;
  log_offset_mark(&raw_log);
  //while(!(stat(filepath, &sts) == -1 && errno == ENOENT)){
  while(trace_get_raw(&raw_log) == EXIT_SUCCESS){
    log_preloop_mark(&raw_log);
    /* Do stuffs */




    /* Post loop processing*/
    log_postloop_mark(&raw_log);
    sched_yield();
  }


  // Free resources
__monitoring_thread_free_resources:
  log_free(&raw_log);
  pthread_exit(0);
}
//==================================================
static char** __create_argv_array(int argc, char** argv){
  char** out = NULL;
  out = (char**)calloc(argc+1, sizeof(char*));
  for(int i=0; i<argc; i++){

    out[i] = (char*) calloc(strlen(argv[i]) + 1, sizeof(char));
    strcpy(out[i], argv[i]);

  }
  return out;
}
static void __clear_argv_array(int argc, char** argv){
  if(!argv)return;
  for(int i=0; i < argc; free(argv[i++]));
  free(argv);
  argv = NULL;
}
//==================================================
static void __error_handle(int cond, const char* str){
  if(cond){
    fputs(str, stderr);
    fputc('\n', stderr);
    exit(EXIT_FAILURE);
  }
}
static int __parse_attr(int argc, char** argv, struct sched_deadline_params_t* params){
  int fill_values = 0;
  int index = -1;

  __error_handle( argc < 3 , usage);

  // Capture arguments and store them in {params}
  for (size_t i = 1; i < argc; i++) {
    if( (!strcmp(argv[i], "-p")) || (!strcmp(argv[i], "--period")) ){
      __error_handle(sscanf(argv[++i], "%lld", &params->period_us) != 1, "Impossible de recueillir la valeur de la période...");
      fill_values |= 1;
    }

    else if( (!strcmp(argv[i], "-d")) || (!strcmp(argv[i], "--deadline")) ){
      __error_handle(sscanf(argv[++i], "%lld", &params->deadline_us) != 1, "Impossible de recueillir la valeur de l'échéance ...");
      fill_values |= 2;
    }

    else if( (!strcmp(argv[i], "-n")) || (!strcmp(argv[i], "--normal_wcet")) ){
      __error_handle(sscanf(argv[++i], "%lld", &params->normal_wcet_us) != 1, "Impossible de recueillir la valeur du pire temps d'exécution normal ...");
      fill_values |= 4;
    }

    else if( (!strcmp(argv[i], "-a")) || (!strcmp(argv[i], "--abnormal_wcet")) ){
      __error_handle(sscanf(argv[++i], "%lld", &params->abnormal_wcet_us) != 1, "Impossible de recueillir la valeur du pire temps d'exécution anormal ...");
      fill_values |= 8;
    }
    else{
      index = i;
      break;
    }
  }

  __error_handle((index == -1), "Erreur, executable non trouvé");
  __error_handle(!(fill_values & (1)), "Erreur, période non définie");

  if(!(fill_values & (1<<1))){
    fprintf(stderr, "Attention, l'échéance n'est pas définie, elle prendra la valeur de la période (%lld us)\n", params->deadline_us = params->period_us);
  }else if(params->deadline_us > params->period_us){
    fprintf(stderr, "Attention, l'échéance est supérieure à la période, elle sera redéfinie sur la valeur de la période (%lld us)\n", params->deadline_us = params->period_us);
  }

  if(!(fill_values & (1<<2))){
    fprintf(stderr, "Attention, le temps d'exécution normal n'est pas défini, il prendra la valeur de l'échéance (%lld us)\n", params->normal_wcet_us = params->deadline_us);
  }else if(params->normal_wcet_us > params->deadline_us){
    fprintf(stderr, "Attention, le temps d'exécution normal est supérieure à l'échéance, il sera redéfini sur la valeur de l'échéance (%lld us)\n", params->normal_wcet_us = params->deadline_us);
  }

  if(!(fill_values & (1<<3))){
    fprintf(stderr, "Attention, le temps d'exécution anormal n'est pas défini, il prendra la valeur du temps d'exécution normal (%lld us)\n", params->abnormal_wcet_us = params->normal_wcet_us);
  }else if(params->normal_wcet_us > params->deadline_us){
    fprintf(stderr, "Attention, le temps d'exécution anormal est supérieure à l'échéance, il sera redéfini sur la valeur de l'échéance (%lld us)\n", params->abnormal_wcet_us = params->deadline_us);
  }


  return index;
}
//==================================================
//==================================================
